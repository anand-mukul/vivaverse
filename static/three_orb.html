<!-- static/three_orb.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EchoViva 3D Orb</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: radial-gradient(circle at center, #030b16 30%, #000 100%);
    height: 100%;
  }
  #container {
    width: 100%;
    height: 100%;
    position: relative;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  /* Fade overlay used when hiding orb */
  #orb-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: transparent;
    transition: background 0.6s ease, opacity 0.6s ease;
    opacity: 1;
  }
  #orb-overlay.hidden {
    opacity: 0;
    background: rgba(0,0,0,0);
  }
</style>
</head>
<body>
<div id="container"></div>
<div id="orb-overlay"></div>

<!-- Three.js CDN (r152) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
(() => {
  // Scene / renderer / camera
  const container = document.getElementById('container');
  const overlay = document.getElementById('orb-overlay');

  const scene = new THREE.Scene();
  const w = container.clientWidth;
  const h = 400; // keep consistent height as embedded in Streamlit
  const camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 1000);
  camera.position.z = 4;

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(w, h);
  container.appendChild(renderer.domElement);

  // Orb core
  const coreGeo = new THREE.SphereGeometry(1.5, 64, 64);
  const coreColor = new THREE.Color('#00FFFF');
  const coreMat = new THREE.MeshPhysicalMaterial({
    color: coreColor,
    emissive: coreColor,
    emissiveIntensity: 0.7,
    roughness: 0.2,
    metalness: 0.1,
    clearcoat: 0.6,
    clearcoatRoughness: 0.1,
    reflectivity: 0.7,
    transparent: false,
  });
  const core = new THREE.Mesh(coreGeo, coreMat);
  scene.add(core);

  // Soft aura (larger transparent sphere)
  const auraGeo = new THREE.SphereGeometry(1.8, 64, 64);
  const auraMat = new THREE.MeshBasicMaterial({
    color: coreColor,
    transparent: true,
    opacity: 0.18,
    blending: THREE.AdditiveBlending
  });
  const aura = new THREE.Mesh(auraGeo, auraMat);
  core.add(aura);

  // Small particle cloud around orb
  const particleCount = 120;
  const positions = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i++) {
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = 2 * Math.PI * Math.random();
    const r = 2.3 + Math.random() * 0.6;
    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
    positions[i * 3 + 2] = r * Math.cos(phi);
  }
  const particleGeo = new THREE.BufferGeometry();
  particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const particleMat = new THREE.PointsMaterial({
    size: 0.03,
    transparent: true,
    opacity: 0.9,
    color: coreColor
  });
  const particles = new THREE.Points(particleGeo, particleMat);
  scene.add(particles);

  // Lighting
  const pLight1 = new THREE.PointLight(0x00ffff, 1.2, 50);
  pLight1.position.set(5, 5, 5);
  scene.add(pLight1);

  const pLight2 = new THREE.PointLight(0xff33ff, 0.1, 50);
  pLight2.position.set(-5, -5, 5);
  scene.add(pLight2);

  scene.add(new THREE.AmbientLight(0x222222));

  // For smooth color transitions
  let targetColor = new THREE.Color(coreColor);
  let currentColor = new THREE.Color(coreColor);

  // Orb visibility control
  let visible = true;

  // Animation loop
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // Gentle rotation
    core.rotation.x += 0.0025;
    core.rotation.y += 0.0035;
    aura.rotation.y += 0.001;

    // Pulse aura opacity subtly
    aura.material.opacity = 0.12 + 0.06 * Math.sin(t * 1.8);

    // Particles drift slowly outward & inward
    const positions = particleGeo.attributes.position.array;
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      positions[i3] += (Math.sin(t * 0.3 + i) * 0.0005);
      positions[i3 + 1] += (Math.cos(t * 0.25 + i) * 0.0005);
    }
    particleGeo.attributes.position.needsUpdate = true;

    // Smooth color interpolation (lerp)
    currentColor.lerp(targetColor, 0.08);
    core.material.color.copy(currentColor);
    core.material.emissive.copy(currentColor);
    aura.material.color.copy(currentColor);
    particleMat.color.copy(currentColor);

    renderer.render(scene, camera);
  }
  animate();

  // Handle window resizing (Streamlit may embed with variable width)
  function onResize() {
    const rect = container.getBoundingClientRect();
    const width = rect.width;
    const height = 400; // fixed height to match Streamlit embed height
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  }
  window.addEventListener('resize', onResize);

  // Event listeners from Python (Streamlit) via CustomEvent
  window.addEventListener('updateOrbColor', (e) => {
    try {
      const c = new THREE.Color(e.detail || '#00FFFF');
      targetColor.copy(c);
      // Flash effect
      aura.material.opacity = 0.35;
      setTimeout(() => { aura.material.opacity = 0.18; }, 250);
    } catch (err) {
      console.warn('updateOrbColor error', err);
    }
  });

  // Hide orb gracefully (fade overlay and pause animation visually)
  window.addEventListener('hideOrb', () => {
    visible = false;
    overlay.style.background = "rgba(0,0,0,0.8)";
    overlay.classList.remove('hidden');
    // Optionally, reduce particle and core visibility
    core.material.opacity = 0;
    aura.material.opacity = 0;
    particleMat.opacity = 0;
    // After a short delay completely hide canvas (keeps DOM stable)
    setTimeout(() => {
      renderer.domElement.style.display = 'none';
    }, 500);
  });

  // Show orb again if needed
  window.addEventListener('showOrb', () => {
    visible = true;
    overlay.classList.add('hidden');
    renderer.domElement.style.display = 'block';
    core.material.opacity = 1;
    aura.material.opacity = 0.18;
    particleMat.opacity = 0.9;
  });

  // Ensure initial sizing correct
  onResize();
})();
</script>
</body>
</html>
