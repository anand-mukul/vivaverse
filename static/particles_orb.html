<!-- static/particles_orb.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EchoViva Orb</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: transparent;
        overflow: hidden;
      }
      #orbContainer {
        width: 100%;
        height: 100%;
        display: block;
      }
      /* small UI hint overlay (optional) */
      .hint {
        position: absolute;
        left: 16px;
        top: 16px;
        color: rgba(230, 238, 243, 0.9);
        font-family: "Poppins", sans-serif;
        font-size: 13px;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="orbContainer"></div>
    <div class="hint">Listening Orb â€” reacts to your voice</div>

    <!-- three.js (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      // Replace this placeholder from server-side before embedding:
      const ORB_COLOR = "{{ORB_COLOR}}"; // e.g. "#0D9488"

      // Basic scene setup
      const container = document.getElementById("orbContainer");
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      const camera = new THREE.PerspectiveCamera(
        40,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.z = 60;

      // lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
      scene.add(hemi);
      const point = new THREE.PointLight(0xffffff, 1);
      point.position.set(50, 50, 50);
      scene.add(point);

      // Create point-sphere (orb) using BufferGeometry for performance
      const PARTICLE_COUNT = 2000;
      const radius = 20;
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const scales = new Float32Array(PARTICLE_COUNT);

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        // random point on sphere surface (uniform distribution)
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = radius + (Math.random() - 0.5) * 1.8; // slight radial noise

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        scales[i] = Math.random() * 1.2 + 0.2;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.setAttribute("aScale", new THREE.BufferAttribute(scales, 1));

      // Points material with size attenuation and vertex colors
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0.0 },
          uColor: { value: new THREE.Color(ORB_COLOR || "#0D9488") },
          uPixelRatio: { value: window.devicePixelRatio || 1.0 },
        },
        vertexShader: `
    precision highp float;
    attribute vec3 position;
    attribute float aScale;
    uniform float uTime;
    uniform float uPixelRatio;
    varying float vScale;

    void main(){
      vScale = aScale;
      vec3 pos = position;

      // simple pulsating displacement along normal direction
      float pulse = sin(uTime * 2.0 + position.x * 0.12 + position.y * 0.08) * 0.8;
      pos = normalize(pos) * (length(position) + pulse * 0.6);

      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = (2.5 + vScale * 2.0) * (300.0 / -mvPosition.z) * (uPixelRatio);
      gl_Position = projectionMatrix * mvPosition;
    }
  `,
        fragmentShader: `
    precision mediump float;
    uniform vec3 uColor;
    varying float vScale;

    void main(){
      // circular soft particle
      float r = length(gl_PointCoord - vec2(0.5));
      float alpha = smoothstep(0.5, 0.0, r);
      vec3 color = uColor;
      // add slight warm core based on scale
      color = mix(color, vec3(1.0, 0.9, 0.6), vScale * 0.12);
      gl_FragColor = vec4(color, alpha);
    }
  `,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const points = new THREE.Points(geometry, material);
      scene.add(points);

      // subtle rotation
      let rotSpeedX = 0.001;
      let rotSpeedY = 0.0015;

      // handle resize
      window.addEventListener("resize", onWindowResize);
      function onWindowResize() {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        material.uniforms.uPixelRatio.value = window.devicePixelRatio || 1.0;
      }

      // animate loop
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        material.uniforms.uTime.value = t;

        // slow rotation
        points.rotation.y += rotSpeedY;
        points.rotation.x += rotSpeedX;

        renderer.render(scene, camera);
      }
      animate();

      // Public API: allow the host to set color or pulse via postMessage
      // This supports Streamlit re-render OR dynamic updates via window.postMessage
      window.updateOrb = function (hexColor, intensity) {
        try {
          if (hexColor) {
            material.uniforms.uColor.value.set(hexColor);
          }
          // intensity controls rotation/pulse amplitude (0..1)
          intensity =
            typeof intensity === "number"
              ? Math.min(Math.max(intensity, 0.0), 1.0)
              : 0.0;
          rotSpeedX = 0.001 + intensity * 0.02;
          rotSpeedY = 0.0015 + intensity * 0.03;

          // subtle scale modulation via vertex shader time; optionally nudge uTime
          material.uniforms.uTime.value += intensity * 0.2;
        } catch (e) {
          console.warn("Orb update failed:", e);
        }
      };

      // Also listen for messages (useful if parent script posts updates)
      window.addEventListener("message", (ev) => {
        try {
          const d = ev.data || {};
          if (d.type === "updateOrb") {
            window.updateOrb(d.color, d.intensity);
          }
        } catch (e) {}
      });

      // initial gentle pulse
      window.setTimeout(() => {
        window.updateOrb(ORB_COLOR || "#0D9488", 0.12);
      }, 300);
    </script>
  </body>
</html>
